import Data.Char
esMin :: Char -> Bool
esMin x = isLower x
contarelementos :: [a] -> Integer
contarelementos [] = 0
contarelementos x = 1 + contarelementos (tail x)
letANat :: Char -> Integer
letANat x | (esMin x) = (contarelementos ['a'..x]) - 1
	  | otherwise = undefined
tomarN :: (Eq a) => Integer -> [a] -> [a]
tomarN n x | (n <= 0) || (x == []) = []
	   | otherwise = [head x] ++ tomarN (n-1) (tail x)
natALet :: Integer -> Char
natALet x | (x >= 0) && (x <= 25) = last (tomarN (x+1) ['a'..'z'])
	  | otherwise = undefined
desplazar :: Integer -> Char -> Char
desplazar n l | (n >= 0) && (n <= 25) && (esMin l) && (letANat l + n <= 25) = natALet (letANat l + n)
	      | (n >= 0) && (n <= 25) && (esMin l) && (letANat l + n > 25) = natALet (letANat l + n - 26)
	      | otherwise = l
codificar :: Integer -> String -> String
codificar n [] = []
codificar n x | n <= 25 = (desplazar n (head x)) : (codificar n (tail x))
codificar n x | otherwise = (desplazar (n- (div n 25)*25) (head x)) : (codificar (n- (div n 25)*25) (tail x))
decodificar :: Integer -> String -> String
decodificar n [] = []
decodificar n x | n <= 25 = (codificar (26-n) x)
decodificar n x | otherwise = (codificar (51-n) x)
